的確なご指摘をありがとうございます！マッチングアルゴリズムの技術仕様が曖昧でした。詳細な技術仕様を定義いたします。

# 🔢 **マッチングアルゴリズム技術仕様**

## 1. **類似度計算ロジック**

### **1.1 総合類似度スコア算出式**
```typescript
総合スコア = Σ(指標値 × 重み) × 補正係数

基本指標:
- コンテンツ類似度 (Content Similarity): 40%
- 評価パターン類似度 (Rating Pattern): 30% 
- 視聴時間帯類似度 (Viewing Time): 15%
- ジャンル嗜好類似度 (Genre Preference): 15%

補正係数:
- アクティブ度補正: 0.8 〜 1.2
- 地域補正: 0.9 〜 1.1
- 年齢層補正: 0.95 〜 1.05
```

### **1.2 各指標の詳細計算式**

#### **A. コンテンツ類似度 (40%重み)**
```typescript
// Jaccard係数 + 重み付きコサイン類似度の組み合わせ
interface VideoWeight {
  videoId: string;
  weight: number; // 視聴完了率 × 評価値 × 時間減衰
}

// 1. 共通動画抽出
const commonVideos = intersection(userA.videos, userB.videos)
const jaccardIndex = commonVideos.length / union(userA.videos, userB.videos).length

// 2. 重み付きベクトル作成
const createWeightedVector = (videos: VideoWeight[]): number[] => {
  return categories.map(category => 
    videos
      .filter(v => v.category === category)
      .reduce((sum, v) => sum + v.weight, 0)
  )
}

// 3. コサイン類似度計算
const cosineSimilarity = (vecA: number[], vecB: number[]): number => {
  const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0)
  const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0))
  const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0))
  
  return magnitudeA && magnitudeB ? dotProduct / (magnitudeA * magnitudeB) : 0
}

// 最終コンテンツ類似度
const contentSimilarity = (jaccardIndex * 0.3) + (cosineSimilarity * 0.7)
```

#### **B. 評価パターン類似度 (30%重み)**
```typescript
// ピアソン相関係数 + 評価分散考慮
interface UserRating {
  videoId: string;
  rating: number; // 1-5
  timestamp: Date;
}

const calculateRatingPattern = (userA: UserRating[], userB: UserRating[]): number => {
  const commonRatings = userA.filter(a => 
    userB.some(b => b.videoId === a.videoId)
  )
  
  if (commonRatings.length < 3) return 0 // 最低3つの共通評価必要
  
  // ピアソン相関係数
  const pearsonCorrelation = calculatePearsonCorrelation(
    commonRatings.map(r => r.rating),
    commonRatings.map(r => userB.find(b => b.videoId === r.videoId)!.rating)
  )
  
  // 評価分散の類似度（厳しい/甘い評価傾向の一致）
  const ratingVarianceA = calculateVariance(userA.map(r => r.rating))
  const ratingVarianceB = calculateVariance(userB.map(r => r.rating))
  const varianceSimilarity = 1 - Math.abs(ratingVarianceA - ratingVarianceB) / 2
  
  return (pearsonCorrelation * 0.7) + (varianceSimilarity * 0.3)
}
```

#### **C. 視聴時間帯類似度 (15%重み)**
```typescript
// 時間帯別視聴パターンの重複度
interface ViewingPattern {
  hour: number; // 0-23
  weekday: number; // 0-6 (日曜=0)
  intensity: number; // 視聴時間数
}

const calculateViewingTimeSimilarity = (
  patternA: ViewingPattern[], 
  patternB: ViewingPattern[]
): number => {
  let overlapScore = 0
  let totalWeight = 0
  
  for (let hour = 0; hour < 24; hour++) {
    const intensityA = patternA.find(p => p.hour === hour)?.intensity || 0
    const intensityB = patternB.find(p => p.hour === hour)?.intensity || 0
    
    if (intensityA > 0 && intensityB > 0) {
      // 重複時間帯での類似度
      const similarity = 1 - Math.abs(intensityA - intensityB) / Math.max(intensityA, intensityB)
      overlapScore += similarity * Math.min(intensityA, intensityB)
      totalWeight += Math.min(intensityA, intensityB)
    }
  }
  
  return totalWeight > 0 ? overlapScore / totalWeight : 0
}
```

#### **D. ジャンル嗜好類似度 (15%重み)**
```typescript
// カテゴリ別視聴時間の分布類似度
interface GenrePreference {
  category: string;
  viewingTime: number; // 分単位
  videoCount: number;
  averageRating: number;
}

const calculateGenreSimilarity = (
  prefsA: GenrePreference[], 
  prefsB: GenrePreference[]
): number => {
  const allGenres = [...new Set([...prefsA, ...prefsB].map(p => p.category))]
  
  let similarity = 0
  for (const genre of allGenres) {
    const prefA = prefsA.find(p => p.category === genre)
    const prefB = prefsB.find(p => p.category === genre)
    
    if (prefA && prefB) {
      // 視聴時間分布の類似度
      const timeRatioA = prefA.viewingTime / prefsA.reduce((sum, p) => sum + p.viewingTime, 0)
      const timeRatioB = prefB.viewingTime / prefsB.reduce((sum, p) => sum + p.viewingTime, 0)
      const timeSimilarity = 1 - Math.abs(timeRatioA - timeRatioB)
      
      // 評価傾向の類似度
      const ratingSimilarity = 1 - Math.abs(prefA.averageRating - prefB.averageRating) / 4
      
      similarity += (timeSimilarity * 0.6 + ratingSimilarity * 0.4) * Math.max(timeRatioA, timeRatioB)
    }
  }
  
  return similarity
}
```

## 2. **閾値設定**

### **2.1 マッチング表示閾値**
```typescript
const MATCHING_THRESHOLDS = {
  STRICT_MODE: {
    minSimilarity: 0.85,        // 85%以上
    minCommonVideos: 20,        // 20本以上共通視聴
    minContentSimilarity: 0.80, // コンテンツ類似度80%以上
    minRatingCorrelation: 0.70, // 評価相関70%以上
    maxDistance: 50,            // 50km圏内
  },
  
  STANDARD_MODE: {
    minSimilarity: 0.70,        // 70%以上
    minCommonVideos: 10,        // 10本以上共通視聴  
    minContentSimilarity: 0.65, // コンテンツ類似度65%以上
    minRatingCorrelation: 0.50, // 評価相関50%以上
    maxDistance: 100,           // 100km圏内
  },
  
  RELAXED_MODE: {
    minSimilarity: 0.60,        // 60%以上
    minCommonVideos: 5,         // 5本以上共通視聴
    minContentSimilarity: 0.50, // コンテンツ類似度50%以上  
    minRatingCorrelation: 0.30, // 評価相関30%以上
    maxDistance: null,          // 全国
  }
}
```

### **2.2 動的閾値調整**
```typescript
// ユーザー数に応じた閾値自動調整
const adjustThresholds = (userCount: number, region: string): ThresholdConfig => {
  let mode = MATCHING_THRESHOLDS.STRICT_MODE
  
  if (userCount < 100) {
    mode = MATCHING_THRESHOLDS.RELAXED_MODE
  } else if (userCount < 500) {
    mode = MATCHING_THRESHOLDS.STANDARD_MODE
  }
  
  // 地域による調整
  if (region === 'rural') {
    mode.maxDistance = mode.maxDistance ? mode.maxDistance * 2 : 200
    mode.minSimilarity *= 0.9
  }
  
  return mode
}
```

## 3. **計算タイミング設計**

### **3.1 ハイブリッド計算方式**
```typescript
// バッチ処理 + リアルタイム更新の組み合わせ
interface ComputationStrategy {
  batchProcess: {
    schedule: 'daily' | 'hourly' | 'on-demand';
    scope: 'all-users' | 'active-users' | 'new-users';
    priority: number;
  };
  realtimeProcess: {
    triggers: string[];
    debounceMs: number;
    maxCandidates: number;
  };
}

const COMPUTATION_CONFIG: ComputationStrategy = {
  batchProcess: {
    schedule: 'daily',       // 毎日午前3時実行
    scope: 'active-users',   // 過去7日間アクティブユーザー対象
    priority: 1
  },
  realtimeProcess: {
    triggers: [
      'new_video_rating',    // 新しい動画評価
      'profile_update',      // プロフィール更新
      'viewing_milestone'    // 視聴マイルストーン(10本毎)
    ],
    debounceMs: 300000,     // 5分間のデバウンス
    maxCandidates: 50       // 最大50件まで即時計算
  }
}
```

### **3.2 バッチ処理詳細**
```typescript
// 毎日午前3時実行のバッチ処理
export const dailyMatchingBatch = async () => {
  const activeUsers = await getActiveUsers(7) // 過去7日間アクティブ
  
  console.log(`Processing ${activeUsers.length} active users`)
  
  // 並列処理でパフォーマンス向上
  const batchSize = 10
  const batches = chunk(activeUsers, batchSize)
  
  for (const batch of batches) {
    await Promise.allSettled(
      batch.map(async (user) => {
        try {
          // 1. 視聴データの前処理
          const viewingData = await preprocessViewingData(user.id)
          
          // 2. 候補ユーザー抽出（地域・年齢等の基本フィルター）
          const candidates = await getCandidateUsers(user)
          
          // 3. 類似度計算
          const similarities = await Promise.all(
            candidates.map(candidate => 
              calculateUserSimilarity(viewingData, candidate.viewingData)
            )
          )
          
          // 4. 結果保存（既存レコードは上書き）
          await saveSimilarityResults(user.id, similarities)
          
          console.log(`Processed user ${user.id}: ${similarities.length} candidates`)
          
        } catch (error) {
          console.error(`Error processing user ${user.id}:`, error)
        }
      })
    )
    
    // バッチ間のインターバル（DB負荷軽減）
    await sleep(1000)
  }
}
```

### **3.3 リアルタイム処理詳細**
```typescript
// リアルタイム類似度更新
export const realtimeMatchingUpdate = async (
  userId: string, 
  trigger: string,
  metadata?: any
) => {
  // デバウンス処理（短時間の連続更新を防ぐ）
  const lastUpdate = await getLastUpdateTime(userId)
  if (Date.now() - lastUpdate < COMPUTATION_CONFIG.realtimeProcess.debounceMs) {
    console.log(`Debounced update for user ${userId}`)
    return
  }
  
  try {
    // 1. トリガーに応じた処理範囲決定
    const scope = determineUpdateScope(trigger, metadata)
    
    // 2. 影響を受ける候補者のみ再計算
    const affectedCandidates = await getAffectedCandidates(userId, scope)
    
    // 3. 部分的類似度更新
    const updates = await Promise.all(
      affectedCandidates.map(async (candidate) => {
        const newScore = await calculateUserSimilarity(userId, candidate.id)
        return {
          userId,
          candidateId: candidate.id,
          similarity: newScore,
          updatedComponents: scope.components
        }
      })
    )
    
    // 4. 差分更新（全体再計算ではなく）
    await updateSimilarityCache(updates)
    
    console.log(`Realtime update for user ${userId}: ${updates.length} candidates updated`)
    
  } catch (error) {
    console.error(`Realtime update error for user ${userId}:`, error)
    // エラー時はバッチ処理に委託
    await queueForBatchProcessing(userId)
  }
}

// 更新範囲決定ロジック
const determineUpdateScope = (trigger: string, metadata: any) => {
  switch (trigger) {
    case 'new_video_rating':
      return {
        components: ['content_similarity', 'rating_pattern'],
        candidateFilter: { sharedVideo: metadata.videoId }
      }
    case 'profile_update':
      return {
        components: ['genre_preference'],
        candidateFilter: { all: true }
      }
    case 'viewing_milestone':
      return {
        components: ['content_similarity', 'viewing_time'],
        candidateFilter: { recentlyActive: true }
      }
    default:
      return { components: ['all'], candidateFilter: { all: true } }
  }
}
```

## 4. **パフォーマンス最適化**

### **4.1 データ前処理・キャッシュ戦略**
```typescript
// ユーザー視聴データの前処理済みベクトル
interface PreprocessedUserData {
  userId: string;
  contentVector: number[];        // カテゴリ別視聴時間ベクトル
  ratingVector: number[];         // 評価パターンベクトル
  viewingTimeVector: number[];    // 時間帯別視聴パターンベクトル
  genrePreferences: GenreStats[]; // ジャンル別統計
  lastUpdated: Date;
  version: number;                // データ構造バージョン
}

// Redis キャッシュ設計
const CACHE_CONFIG = {
  preprocessedData: {
    keyPattern: 'user_vector:{userId}',
    ttl: 3600 * 24 * 7,  // 7日間
    compressionType: 'gzip'
  },
  similarityMatrix: {
    keyPattern: 'similarity:{userId}:{candidateId}',
    ttl: 3600 * 24,      // 24時間
    maxEntries: 1000     // ユーザーあたり最大1000件
  },
  candidatePool: {
    keyPattern: 'candidates:{userId}',
    ttl: 3600 * 6,       // 6時間
    maxCandidates: 100
  }
}
```

### **4.2 計算効率化**
```typescript
// 近似アルゴリズム使用による高速化
import { LSH } from 'locality-sensitive-hashing'

// Locality Sensitive Hashing で類似ユーザーの高速検索
const lshIndex = new LSH({
  dimensions: 100,      // 特徴ベクトル次元数
  hashFunctions: 10,    // ハッシュ関数数
  buckets: 50          // バケット数
})

// 段階的計算による早期終了
const calculateSimilarityWithEarlyExit = async (
  userA: string, 
  userB: string
): Promise<number | null> => {
  // Stage 1: 基本フィルター（高速）
  const basicSimilarity = await calculateBasicSimilarity(userA, userB)
  if (basicSimilarity < 0.3) return null // 早期終了
  
  // Stage 2: コンテンツ類似度（中程度）
  const contentSim = await calculateContentSimilarity(userA, userB)
  if ((basicSimilarity * 0.3 + contentSim * 0.4) < 0.5) return null
  
  // Stage 3: 詳細計算（重い）
  return await calculateFullSimilarity(userA, userB)
}
```

## 5. **監視・調整メカニズム**

### **5.1 アルゴリズム性能監視**
```typescript
// マッチング品質指標
interface MatchingMetrics {
  // 精度指標
  matchSuccessRate: number;      // マッチング成功率
  chatInitiationRate: number;    // チャット開始率
  conversationContinuationRate: number; // 会話継続率
  
  // 効率指標  
  averageCalculationTime: number; // 平均計算時間
  cacheHitRate: number;          // キャッシュヒット率
  falsePositiveRate: number;     // 誤判定率
  
  // 分布指標
  similarityDistribution: number[]; // スコア分布
  candidateCountDistribution: number[]; // 候補数分布
}

// A/Bテスト用の重み調整
const WEIGHT_VARIATIONS = {
  contentFocused: {
    content: 0.50, rating: 0.25, viewing: 0.15, genre: 0.10
  },
  behaviorFocused: {
    content: 0.30, rating: 0.40, viewing: 0.20, genre: 0.10
  },
  timeFocused: {
    content: 0.35, rating: 0.25, viewing: 0.30, genre: 0.10
  }
}
```

### **5.2 自動調整機能**
```typescript
// 週次でのアルゴリズム自動調整
export const weeklyAlgorithmTuning = async () => {
  const metrics = await collectWeeklyMetrics()
  
  // 成功率が低い場合の閾値調整
  if (metrics.matchSuccessRate < 0.15) {
    await adjustThresholds('relax')
    console.log('Relaxed matching thresholds due to low success rate')
  }
  
  // 候補数が少ない場合の重み調整
  if (metrics.averageCandidateCount < 5) {
    await adjustWeights('increase_recall') 
    console.log('Adjusted weights to increase recall')
  }
  
  // 計算時間が長い場合の最適化
  if (metrics.averageCalculationTime > 5000) {
    await enableApproximationMode()
    console.log('Enabled approximation mode for performance')
  }
}
```

この技術仕様で**アルゴリズムの実装詳細**が明確になりましたでしょうか？

追加で詳細が必要な部分や、調整したい閾値・重み設定があれば教えてください！